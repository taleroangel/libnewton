// @generated
// This file is @generated by prost-build.
/// Memory Addressing mode for A & B parameters\
/// Addressing is represented with two bits at the end of the instruction byte (00000011),
/// first bit represents the first parameter (A) and the second bit represents the second parameter (B).
/// When a bit is set to 1 then indirect addressing must be used
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddressingMode {
    /// Use immediate addressing for both A & B parameters
    AbImmediate = 0,
    /// Use indirect addressing for B and immediate addressing for A
    BIndirect = 1,
    /// Use indirect addressing for A and immediate addressing for B
    AIndirect = 2,
    /// Use immediate addressing for both A & B parameters
    AbIndirect = 3,
}
impl AddressingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AddressingMode::AbImmediate => "AB_IMMEDIATE",
            AddressingMode::BIndirect => "B_INDIRECT",
            AddressingMode::AIndirect => "A_INDIRECT",
            AddressingMode::AbIndirect => "AB_INDIRECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AB_IMMEDIATE" => Some(Self::AbImmediate),
            "B_INDIRECT" => Some(Self::BIndirect),
            "A_INDIRECT" => Some(Self::AIndirect),
            "AB_INDIRECT" => Some(Self::AbIndirect),
            _ => None,
        }
    }
}
/// Current status bitmask stored in $SF register
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatusFlags {
    /// Device is halted, halt value mut be inside $SC
    /// Device will not respond to commands unless BEGIN, RESET or TRANSMIT is issued
    Ht = 0,
    /// Device is in script mode (script starts execution on RUN command)
    St = 1,
    /// Device is in transmit mode, no state machine (branching disabled)
    Tx = 2,
    Ix = 3,
    Hd = 4,
    Ow = 5,
}
impl StatusFlags {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StatusFlags::Ht => "HT",
            StatusFlags::St => "ST",
            StatusFlags::Tx => "TX",
            StatusFlags::Ix => "IX",
            StatusFlags::Hd => "HD",
            StatusFlags::Ow => "OW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HT" => Some(Self::Ht),
            "ST" => Some(Self::St),
            "TX" => Some(Self::Tx),
            "IX" => Some(Self::Ix),
            "HD" => Some(Self::Hd),
            "OW" => Some(Self::Ow),
            _ => None,
        }
    }
}
/// 8-bit memory registers
/// There are 10 well-known registers (0-9) and 32 general purpose registers (10-31)
/// General purpose registers are named with a $ without considering the well-known registers, so register $0 becomes 10 and $31 becomes 41
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Registers {
    /// Status Code, current execution status code. 0 for success
    Sc = 0,
    /// Status Flags, contains a bitmask representing all of the state flags
    Sf = 1,
    /// Program Counter, keep the current instruction on the script
    /// Beware: disabled on TRANSMIT mode
    Pc = 3,
    /// Previous Program Counter, keeps the previous program counter when branching
    Pp = 4,
    /// Return Value, Contains the returned value by the last routine
    Rv = 5,
    /// Range Start (Inclusive) Absolute index of the current selected start position
    R0 = 6,
    /// Range End (Exclusive) Absolute index of the current selected end position
    R1 = 7,
    /// Current amount of pending operations
    Po = 8,
    /// General purpose register offset
    General = 10,
}
impl Registers {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Registers::Sc => "SC",
            Registers::Sf => "SF",
            Registers::Pc => "PC",
            Registers::Pp => "PP",
            Registers::Rv => "RV",
            Registers::R0 => "R0",
            Registers::R1 => "R1",
            Registers::Po => "PO",
            Registers::General => "GENERAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SC" => Some(Self::Sc),
            "SF" => Some(Self::Sf),
            "PC" => Some(Self::Pc),
            "PP" => Some(Self::Pp),
            "RV" => Some(Self::Rv),
            "R0" => Some(Self::R0),
            "R1" => Some(Self::R1),
            "PO" => Some(Self::Po),
            "GENERAL" => Some(Self::General),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
